import{a as D,b as z}from"./main-CxpZHTDM.js";const F={},_=r=>{let a;const o=new Set,s=(f,y)=>{const m=typeof f=="function"?f(a):f;if(!Object.is(m,a)){const S=a;a=y??(typeof m!="object"||m===null)?m:Object.assign({},a,m),o.forEach(p=>p(a,S))}},c=()=>a,d={setState:s,getState:c,getInitialState:()=>l,subscribe:f=>(o.add(f),()=>o.delete(f)),destroy:()=>{(F?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),o.clear()}},l=a=r(s,c,d);return d},P=r=>r?_(r):_,w={},{useDebugValue:T}=z,{useSyncExternalStoreWithSelector:x}=D;let I=!1;const C=r=>r;function j(r,a=C,o){(w?"production":void 0)!=="production"&&o&&!I&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),I=!0);const s=x(r.subscribe,r.getState,r.getServerState||r.getInitialState,a,o);return T(s),s}const E=r=>{(w?"production":void 0)!=="production"&&typeof r!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const a=typeof r=="function"?P(r):r,o=(s,c)=>j(a,s,c);return Object.assign(o,a),o},W=r=>r?E(r):E,A={};function J(r,a){let o;try{o=r()}catch{return}return{getItem:c=>{var t;const g=d=>d===null?null:JSON.parse(d,void 0),v=(t=o.getItem(c))!=null?t:null;return v instanceof Promise?v.then(g):g(v)},setItem:(c,t)=>o.setItem(c,JSON.stringify(t,void 0)),removeItem:c=>o.removeItem(c)}}const b=r=>a=>{try{const o=r(a);return o instanceof Promise?o:{then(s){return b(s)(o)},catch(s){return this}}}catch(o){return{then(s){return this},catch(s){return b(s)(o)}}}},N=(r,a)=>(o,s,c)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:n=>n,version:0,merge:(n,u)=>({...u,...n}),...a},g=!1;const v=new Set,d=new Set;let l;try{l=t.getStorage()}catch{}if(!l)return r((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),o(...n)},s,c);const f=b(t.serialize),y=()=>{const n=t.partialize({...s()});let u;const e=f({state:n,version:t.version}).then(h=>l.setItem(t.name,h)).catch(h=>{u=h});if(u)throw u;return e},m=c.setState;c.setState=(n,u)=>{m(n,u),y()};const S=r((...n)=>{o(...n),y()},s,c);let p;const i=()=>{var n;if(!l)return;g=!1,v.forEach(e=>e(s()));const u=((n=t.onRehydrateStorage)==null?void 0:n.call(t,s()))||void 0;return b(l.getItem.bind(l))(t.name).then(e=>{if(e)return t.deserialize(e)}).then(e=>{if(e)if(typeof e.version=="number"&&e.version!==t.version){if(t.migrate)return t.migrate(e.state,e.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return e.state}).then(e=>{var h;return p=t.merge(e,(h=s())!=null?h:S),o(p,!0),y()}).then(()=>{u?.(p,void 0),g=!0,d.forEach(e=>e(p))}).catch(e=>{u?.(void 0,e)})};return c.persist={setOptions:n=>{t={...t,...n},n.getStorage&&(l=n.getStorage())},clearStorage:()=>{l?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>i(),hasHydrated:()=>g,onHydrate:n=>(v.add(n),()=>{v.delete(n)}),onFinishHydration:n=>(d.add(n),()=>{d.delete(n)})},i(),p||S},L=(r,a)=>(o,s,c)=>{let t={storage:J(()=>localStorage),partialize:i=>i,version:0,merge:(i,n)=>({...n,...i}),...a},g=!1;const v=new Set,d=new Set;let l=t.storage;if(!l)return r((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),o(...i)},s,c);const f=()=>{const i=t.partialize({...s()});return l.setItem(t.name,{state:i,version:t.version})},y=c.setState;c.setState=(i,n)=>{y(i,n),f()};const m=r((...i)=>{o(...i),f()},s,c);c.getInitialState=()=>m;let S;const p=()=>{var i,n;if(!l)return;g=!1,v.forEach(e=>{var h;return e((h=s())!=null?h:m)});const u=((n=t.onRehydrateStorage)==null?void 0:n.call(t,(i=s())!=null?i:m))||void 0;return b(l.getItem.bind(l))(t.name).then(e=>{if(e)if(typeof e.version=="number"&&e.version!==t.version){if(t.migrate)return[!0,t.migrate(e.state,e.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,e.state];return[!1,void 0]}).then(e=>{var h;const[R,H]=e;if(S=t.merge(H,(h=s())!=null?h:m),o(S,!0),R)return f()}).then(()=>{u?.(S,void 0),S=s(),g=!0,d.forEach(e=>e(S))}).catch(e=>{u?.(void 0,e)})};return c.persist={setOptions:i=>{t={...t,...i},i.storage&&(l=i.storage)},clearStorage:()=>{l?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>p(),hasHydrated:()=>g,onHydrate:i=>(v.add(i),()=>{v.delete(i)}),onFinishHydration:i=>(d.add(i),()=>{d.delete(i)})},t.skipHydration||p(),S||m},O=(r,a)=>"getStorage"in a||"serialize"in a||"deserialize"in a?((A?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),N(r,a)):L(r,a),$=O;export{W as a,P as c,$ as p};
